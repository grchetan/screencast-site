<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Screencast Site — P2P Sharing (HTML/CSS/JS)</title>

    <!--
  Enhanced Screencast Site with P2P Sharing
  - Uses PeerJS for WebRTC P2P (signaling via their broker, no custom server needed).
  - High-quality screen capture: 1080p@60fps ideal, VP9 codec.
  - Bidirectional sharing: Create room by auto-ID or join by username/ID.
  - Remote preview: Laptop screen visible on mobile (and vice versa) via WebRTC.
  - Local recording with high quality.
  - Fallback: Camera if screen share not supported (e.g., iOS Safari).
  - Quality: High res constraints, always cursor, system audio where possible.
  - NOTE: Requires HTTPS. PeerJS uses free broker (rate-limited for heavy use).
  - For production, consider custom signaling server.
-->

    <style>
      :root {
        --bg: #f7f8fb;
        --card: #ffffff;
        --text: #0f172a;
        --muted: #6b7280;
        --accent: #2563eb;
        --danger: #ef4444;
        --success: #10b981;
        --radius: 12px;
        --shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
      }
      .dark {
        --bg: #071029;
        --card: #071a2b;
        --text: #e6eef8;
        --muted: #94a3b8;
        --accent: #60a5fa;
        --danger: #fb7185;
        --success: #34d399;
        --shadow: none;
      }

      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
          Roboto, "Helvetica Neue";
        background: var(--bg);
        color: var(--text);
        -webkit-font-smoothing: antialiased;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }
      .wrap {
        width: 100%;
        max-width: 980px;
      }
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 14px;
      }
      h1 {
        font-size: 1.1rem;
        margin: 0;
      }
      .sub {
        color: var(--muted);
        font-size: 0.86rem;
      }

      .card {
        background: var(--card);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      #localPreview,
      #remotePreview {
        width: 100%;
        height: 56vh;
        background: #000;
        border-radius: 10px;
        object-fit: contain;
        display: block;
      }
      @media (max-width: 600px) {
        #localPreview,
        #remotePreview {
          height: 45vh;
        }
      }

      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .btn {
        padding: 10px 14px;
        border-radius: 10px;
        border: 1px solid rgba(15, 23, 42, 0.06);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.9),
          rgba(255, 255, 255, 0.82)
        );
        cursor: pointer;
        font-weight: 600;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .primary {
        background: linear-gradient(180deg, var(--accent), #1e40af);
        color: white;
        border: 0;
      }
      .success {
        background: linear-gradient(180deg, var(--success), #059669);
        color: white;
        border: 0;
      }
      .danger {
        background: linear-gradient(180deg, var(--danger), #b91c1c);
        color: white;
        border: 0;
      }
      .muted {
        background: transparent;
        border: 1px solid rgba(15, 23, 42, 0.06);
      }

      .status-row {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }
      .status {
        font-weight: 700;
      }
      .recording-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: var(--danger);
        box-shadow: 0 0 8px rgba(239, 68, 68, 0.35);
      }
      .timer {
        font-family: monospace;
        background: rgba(0, 0, 0, 0.04);
        padding: 6px 8px;
        border-radius: 8px;
        color: var(--muted);
      }

      .help {
        font-size: 0.9rem;
        color: var(--muted);
        line-height: 1.4;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      input[type="text"] {
        padding: 8px 12px;
        border: 1px solid rgba(15, 23, 42, 0.06);
        border-radius: 8px;
        font-size: 0.9rem;
      }
      .peer-id {
        background: rgba(37, 99, 235, 0.1);
        padding: 8px;
        border-radius: 8px;
        font-family: monospace;
        font-weight: bold;
        word-break: break-all;
      }

      footer {
        margin-top: 10px;
        color: var(--muted);
        font-size: 0.85rem;
        text-align: center;
      }

      a.link {
        color: var(--accent);
        text-decoration: none;
        font-weight: 600;
      }

      /* small responsive card actions */
      .small-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      /* P2P Section */
      .p2p-section {
        border-top: 1px solid rgba(15, 23, 42, 0.06);
        padding-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .p2p-row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div>
          <h1>Screencast Site — P2P Enhanced</h1>
          <div class="sub">
            High-quality screen share between devices (laptop ↔ mobile). Use ID
            to connect.
          </div>
        </div>
        <div class="toggle">
          <label for="darkSwitch" class="sub">Dark</label>
          <input
            id="darkSwitch"
            type="checkbox"
            aria-label="Toggle dark mode"
          />
        </div>
      </header>

      <main class="card" role="main">
        <!-- Local Preview -->
        <video id="localPreview" playsinline autoplay muted controls></video>
        <!-- Remote Preview -->
        <video id="remotePreview" playsinline autoplay controls></video>

        <!-- P2P Controls -->
        <div class="p2p-section">
          <div class="p2p-row">
            <label for="peerIdInput" class="sub">Join by ID:</label>
            <input
              type="text"
              id="peerIdInput"
              placeholder="Enter ID/Username"
            />
            <button id="joinBtn" class="btn primary">Join</button>
          </div>
          <div id="myPeerIdSection" style="display: none">
            <div class="row">
              <span class="sub">Your ID:</span>
              <div id="myPeerId" class="peer-id"></div>
              <button id="copyIdBtn" class="btn muted">Copy ID</button>
            </div>
            <div class="sub" id="shareHint">
              Share this ID with the other device to connect.
            </div>
          </div>
          <div id="connectionStatus" class="status" style="display: none"></div>
        </div>

        <!-- Controls -->
        <div class="controls">
          <button
            id="shareBtn"
            class="btn primary"
            title="Start sharing your screen"
          >
            Start Screen Share
          </button>
          <button id="recordBtn" class="btn" disabled>Start Recording</button>
          <button id="stopBtn" class="btn muted" disabled>Stop All</button>
          <a
            id="downloadLink"
            class="btn muted"
            style="display: none"
            download="screencast.webm"
            >Download Recording</a
          >
        </div>

        <!-- Status & Timer -->
        <div class="status-row">
          <div id="statusText" class="status">Idle</div>
          <div id="recordIndicator" style="display: none" class="row">
            <div class="recording-dot" aria-hidden></div>
            <div style="min-width: 60px" id="timer" class="timer">00:00</div>
          </div>
          <div
            style="margin-left: auto; color: var(--muted)"
            id="sizeInfo"
          ></div>
        </div>

        <!-- Help & Fallback -->
        <div class="help" id="helpBox">
          <p id="supportMsg">Initializing P2P connection...</p>
          <p id="hint" style="margin-top: 6px">
            Tip: Use HTTPS. High quality (1080p@60fps). Share ID for remote
            viewing. Mobile screen share may fallback to camera.
          </p>
          <div class="small-actions" id="fallbackActions" style="display: none">
            <button id="cameraFallback" class="btn">
              Use Camera (Fallback)
            </button>
          </div>
        </div>
      </main>

      <footer>
        <div>
          P2P via PeerJS. For best quality, use Chrome/Firefox. Test on
          localhost:8000 or deploy to HTTPS.
        </div>
        <div style="margin-top: 6px">
          Bidirectional: Both devices can share screens after connecting.
        </div>
      </footer>
    </div>

    <!-- PeerJS CDN -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
      /* ===========================
   Enhanced Screencast Site - JS Logic
   - PeerJS for P2P WebRTC
   - High-quality constraints
   - Bidirectional sharing via ID
   - Local recording (unchanged, but high quality)
   ============================ */

      const shareBtn = document.getElementById("shareBtn");
      const recordBtn = document.getElementById("recordBtn");
      const stopBtn = document.getElementById("stopBtn");
      const localPreview = document.getElementById("localPreview");
      const remotePreview = document.getElementById("remotePreview");
      const downloadLink = document.getElementById("downloadLink");
      const statusText = document.getElementById("statusText");
      const recordIndicator = document.getElementById("recordIndicator");
      const timerEl = document.getElementById("timer");
      const sizeInfo = document.getElementById("sizeInfo");
      const supportMsg = document.getElementById("supportMsg");
      const fallbackActions = document.getElementById("fallbackActions");
      const cameraFallbackBtn = document.getElementById("cameraFallback");
      const darkSwitch = document.getElementById("darkSwitch");

      // P2P Elements
      const joinBtn = document.getElementById("joinBtn");
      const peerIdInput = document.getElementById("peerIdInput");
      const myPeerIdSection = document.getElementById("myPeerIdSection");
      const myPeerId = document.getElementById("myPeerId");
      const copyIdBtn = document.getElementById("copyIdBtn");
      const connectionStatus = document.getElementById("connectionStatus");

      let stream = null;
      let mediaRecorder = null;
      let recordedChunks = [];
      let recordingStart = null;
      let timerInterval = null;

      // PeerJS
      let peer = null;
      let remotePeerId = null;
      let currentCall = null;

      // Dark mode
      darkSwitch.addEventListener("change", () => {
        document.documentElement.classList.toggle("dark", darkSwitch.checked);
      });

      // High-quality constraints
      const highQualityConstraints = {
        video: {
          mediaSource: "screen",
          width: { ideal: 1920, max: 1920 },
          height: { ideal: 1080, max: 1080 },
          frameRate: { ideal: 60, max: 60 },
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          sampleRate: 48000,
        },
      };

      // Feature detection
      const supportsGetDisplayMedia = !!(
        navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia
      );
      if (supportsGetDisplayMedia) {
        supportMsg.textContent = "High-quality screen capture ready.";
      } else {
        supportMsg.innerHTML =
          "<strong>Screen sharing limited on this device.</strong> Falling back to camera.";
        fallbackActions.style.display = "block";
      }

      // Initialize PeerJS (auto-generate ID)
      function initPeer() {
        peer = new Peer(undefined, {
          host: "peerjs.com",
          port: 443,
          path: "/peerjs",
          config: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              {
                urls: "turn:numb.viagenie.ca",
                username: "webrtc@live.com",
                credential: "muazkh",
              }, // Free TURN fallback
            ],
          },
        });

        peer.on("open", (id) => {
          myPeerId.textContent = id;
          myPeerIdSection.style.display = "block";
          supportMsg.textContent = "P2P ready. Share your ID!";
        });

        peer.on("error", (err) => {
          console.error("Peer error:", err);
          supportMsg.textContent = "P2P connection failed. Check network.";
        });

        // Handle incoming calls (auto-answer for simplicity)
        peer.on("call", (call) => {
          currentCall = call;
          navigator.mediaDevices
            .getUserMedia({ audio: true, video: false })
            .then((localAudioStream) => {
              call.answer(localAudioStream); // Answer with audio only if no video yet
              handleCall(call);
            })
            .catch(() => call.answer()); // No audio fallback

          // If we have local stream, call back for bidirectional
          if (stream) {
            callBackToPeer(call.peer);
          }
        });

        // Handle data connections if needed (future chat)
        peer.on("connection", (conn) => {
          conn.on("data", (data) => console.log("Received:", data));
        });
      }

      // Join peer by ID
      joinBtn.addEventListener("click", () => {
        const id = peerIdInput.value.trim();
        if (!id || !peer) return alert("Enter valid ID and wait for P2P init.");
        remotePeerId = id;
        connectionStatus.textContent = "Connecting...";
        connectionStatus.style.display = "block";
        connectionStatus.style.color = "var(--accent)";

        // Connect data channel (optional)
        const conn = peer.connect(id);
        conn.on("open", () => {
          connectionStatus.textContent =
            "Connected! Start sharing on both devices.";
          connectionStatus.style.color = "var(--success)";
        });
        conn.on("error", () => {
          connectionStatus.textContent = "Connection failed.";
          connectionStatus.style.color = "var(--danger)";
        });

        // Call the remote peer
        navigator.mediaDevices
          .getUserMedia({ audio: true, video: false })
          .then((localAudioStream) => {
            currentCall = peer.call(id, localAudioStream);
            handleCall(currentCall);
          })
          .catch(() => {
            currentCall = peer.call(id, null);
            handleCall(currentCall);
          });
      });

      // Handle call (incoming or outgoing)
      function handleCall(call) {
        call.on("stream", (remoteStream) => {
          remotePreview.srcObject = remoteStream;
          remotePreview.play().catch(() => {});
          statusText.textContent += " | Remote stream active";
        });
        call.on("close", () => {
          remotePreview.srcObject = null;
          connectionStatus.textContent = "Disconnected";
          connectionStatus.style.display = "none";
        });
      }

      // Call back for bidirectional
      function callBackToPeer(targetId) {
        if (stream && peer && targetId !== peer.id) {
          const audioStream = new MediaStream(stream.getAudioTracks());
          const call = peer.call(targetId, audioStream);
          handleCall(call);
        }
      }

      // Copy ID
      copyIdBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(myPeerId.textContent).then(() => {
          copyIdBtn.textContent = "Copied!";
          setTimeout(() => {
            copyIdBtn.textContent = "Copy ID";
          }, 2000);
        });
      });

      // Start screen share (high quality)
      shareBtn.addEventListener("click", async () => {
        stopAllTracks();

        try {
          if (supportsGetDisplayMedia) {
            stream = await navigator.mediaDevices.getDisplayMedia(
              highQualityConstraints
            );
          } else {
            throw new Error("getDisplayMedia not supported");
          }

          localPreview.srcObject = stream;
          localPreview.play().catch(() => {});
          statusText.textContent = "High-quality screen sharing active";
          recordBtn.disabled = false;
          stopBtn.disabled = false;
          downloadLink.style.display = "none";
          sizeInfo.textContent = "";

          // Auto-call remote if connected
          if (remotePeerId) {
            callBackToPeer(remotePeerId);
          }

          // Handle end
          stream.getVideoTracks().forEach((track) => {
            track.addEventListener("ended", stopAllTracks);
          });
        } catch (err) {
          console.error("Screen share error", err);
          statusText.textContent = "Screen share failed";
          alert("Screen sharing failed. Ensure HTTPS and permissions.");
        }
      });

      // Camera fallback
      cameraFallbackBtn.addEventListener("click", async () => {
        try {
          stopAllTracks();
          stream = await navigator.mediaDevices.getUserMedia({
            video: highQualityConstraints.video, // High res camera
            audio: true,
          });
          localPreview.srcObject = stream;
          localPreview.play().catch(() => {});
          statusText.textContent = "High-quality camera fallback";
          recordBtn.disabled = false;
          stopBtn.disabled = false;
          downloadLink.style.display = "none";
          sizeInfo.textContent = "";
          if (remotePeerId) callBackToPeer(remotePeerId);
        } catch (err) {
          console.error("Camera error", err);
          alert("Camera access denied.");
        }
      });

      // Recording (high quality VP9)
      recordBtn.addEventListener("click", () => {
        if (!mediaRecorder || mediaRecorder.state === "inactive")
          startRecording();
        else stopRecording();
      });

      stopBtn.addEventListener("click", stopAllTracks);

      function startRecording() {
        if (!stream) return alert("Start sharing first.");

        recordedChunks = [];
        let options = { mimeType: "video/webm;codecs=vp9" }; // High quality VP9
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options = { mimeType: "video/webm;codecs=vp8" };
        }
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options = { mimeType: "video/webm" };
        }

        try {
          mediaRecorder = new MediaRecorder(stream, options);
        } catch (e) {
          alert("High-quality recording not supported.");
          return;
        }

        mediaRecorder.ondataavailable = (ev) => {
          if (ev.data && ev.data.size > 0) recordedChunks.push(ev.data);
          const size = recordedChunks.reduce((s, b) => s + b.size, 0);
          sizeInfo.textContent = size > 0 ? readableBytes(size) : "";
        };

        mediaRecorder.onstart = () => {
          recordingStart = Date.now();
          startTimer();
          recordIndicator.style.display = "flex";
          statusText.textContent += " | Recording…";
          recordBtn.textContent = "Stop Recording";
          recordBtn.classList.add("danger");
        };

        mediaRecorder.onstop = () => {
          stopTimer();
          recordIndicator.style.display = "none";
          statusText.textContent = statusText.textContent.replace(
            " | Recording…",
            ""
          );
          recordBtn.textContent = "Start Recording";
          recordBtn.classList.remove("danger");

          const blob = new Blob(recordedChunks, { type: "video/webm" });
          const url = URL.createObjectURL(blob);
          downloadLink.href = url;
          downloadLink.style.display = "inline-block";
          downloadLink.textContent = `Download (${readableBytes(blob.size)})`;
          sizeInfo.textContent = readableBytes(blob.size);
        };

        mediaRecorder.onerror = (ev) => alert("Recording error: " + ev.error);

        mediaRecorder.start(100); // Smaller slices for better quality
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
        }
      }

      function stopAllTracks() {
        stopRecording();
        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
        }
        stream = null;
        localPreview.srcObject = null;
        if (currentCall) currentCall.close();
        recordBtn.disabled = true;
        stopBtn.disabled = true;
        statusText.textContent = "Stopped";
      }

      // Timer utils
      function startTimer() {
        timerEl.textContent = "00:00";
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
          const diff = Date.now() - recordingStart;
          timerEl.textContent = formatTime(diff);
        }, 500);
      }
      function stopTimer() {
        if (timerInterval) clearInterval(timerInterval);
      }
      function formatTime(ms) {
        const total = Math.floor(ms / 1000);
        const s = total % 60;
        const m = Math.floor(total / 60) % 60;
        const h = Math.floor(total / 3600);
        return (
          (h > 0 ? String(h).padStart(2, "0") + ":" : "") +
          String(m).padStart(2, "0") +
          ":" +
          String(s).padStart(2, "0")
        );
      }
      function readableBytes(bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + " KB";
        return (bytes / (1024 * 1024)).toFixed(2) + " MB";
      }

      // Init on load
      initPeer();

      // Cleanup on unload
      window.addEventListener("beforeunload", () => {
        if (peer) peer.destroy();
        stopAllTracks();
      });
    </script>
  </body>
</html>
